# dynamic-orms
So first point out how over a few labs the student may have noticed a ton of doing the same thing over and over again. It boils down to a few things: Making the attributes hash. Drop Table. find_by_id. So first abstract those. Table name is equal to pluralized version class name. So show how you can get the class name, then we can ask for an array of the column names for that given table. Where does this belong? A bunch of different objects can use it, so let's put it in a super class that things then inherit from. Show that the class name is actually whichever class you initialized, even if the code is defined in the superclass. Now add find_by_id. Another case where you need the table name, refactor to create a table name method. Drop Table is next. Then the next thing is the .all method. This is a bit harder. Show that the SELECT statement is easy to write, but converting that return into a bunch of Student/Artist/Whatever objects is different for every object. Let's start with something simple and super hard code it. How would you write this in two classes? (do it in two classes) what is different? just the setting of the attributes. So how can make the settings of attributes be dynamic. We already dynamically create the hash. Let's iterate over the return from a select and just set attribute = value. (something like this: https://github.com/learn-co-curriculum/dynamic-orm/blob/ec00c433c6facd0200f1f94ced82a878da6344b6/app/models/flactive_record_base.rb#L56-L61 and this: https://github.com/learn-co-curriculum/dynamic-orm/blob/ec00c433c6facd0200f1f94ced82a878da6344b6/app/models/flactive_record_base.rb#L31-L41) To get the attributes and values in a hash format, you need to set an attribute on the SQLite3 DB. Check this out http://www.rubydoc.info/github/luislavena/sqlite3-ruby/SQLite3%2FDatabase%3Aresults_as_hash.
